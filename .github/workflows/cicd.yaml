name: Fractal CI/CD

on:
  push:
    branches: ["main"]

jobs:
  build-and-scan:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [backend, frontend]

    steps:
      - uses: actions/checkout@v4

      - name: Login to Azure CLI
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Login to ACR
        run: az acr login --name ${{ secrets.ACR_NAME }}

      - name: Setup Trivy
        uses: aquasecurity/setup-trivy@v0.2.3
        with:
          version: v0.65.0

      - name: Set service env
        run: echo "SERVICE=${{ matrix.service }}" >> $GITHUB_ENV

      - name: Build Docker image
        run: |
          docker build -t ${{ secrets.ACR_NAME }}.azurecr.io/${SERVICE}:blue \
                       -t ${{ secrets.ACR_NAME }}.azurecr.io/${SERVICE}:latest ./${SERVICE}

      # ==============================
      # NEW: TRIVY ACTION SCAN (FIXED)
      # ==============================
      - name: Run Trivy Image Scan (Action) - ${{ matrix.service }}
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ secrets.ACR_NAME }}.azurecr.io/${{ matrix.service }}:latest
          format: table
          exit-code: '1'
          severity: CRITICAL
          ignore-unfixed: true
          vuln-type: os,library
        env:
          TRIVY_PLATFORM: linux/amd64

      # ==============================
      # ORIGINAL CLI SCAN (UNCHANGED)
      # ==============================
      - name: Scan Docker image with Trivy CLI
        run: |
          trivy image --exit-code 0 --severity HIGH,CRITICAL \
          ${{ secrets.ACR_NAME }}.azurecr.io/${SERVICE}:blue

      - name: Push Docker image to ACR
        run: |
          docker push ${{ secrets.ACR_NAME }}.azurecr.io/${SERVICE}:blue
          docker push ${{ secrets.ACR_NAME }}.azurecr.io/${SERVICE}:latest

  deploy:
    needs: build-and-scan
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set AKS Context
        uses: azure/aks-set-context@v3
        with:
          resource-group: ${{ secrets.AKS_RG }}
          cluster-name: ${{ secrets.AKS_CLUSTER }}

      - name: Determine next color (BLUE/GREEN)
        id: next-color
        run: |
          BACKEND_CUR=$(kubectl get svc backend-service -o jsonpath='{.spec.selector.version}' || echo green)
          FRONTEND_CUR=$(kubectl get svc frontend-service -o jsonpath='{.spec.selector.version}' || echo green)

          echo "BACKEND_NEXT=$( [ "$BACKEND_CUR" = "blue" ] && echo green || echo blue )" >> $GITHUB_OUTPUT
          echo "FRONTEND_NEXT=$( [ "$FRONTEND_CUR" = "blue" ] && echo green || echo blue )" >> $GITHUB_OUTPUT

      - name: Deploy MySQL & Apps
        run: |
          kubectl apply -f k8s/mysql-deployment.yaml
          kubectl apply -f k8s/backend/backend-bluegreen.yaml
          kubectl apply -f k8s/frontend/frontend-bluegreen.yaml

      - name: Ensure backend & frontend services exist
        run: |
          kubectl apply -f k8s/backend/backend-service.yaml
          kubectl apply -f k8s/frontend/frontend-service.yaml

      - name: Switch services to next color
        run: |
          kubectl patch service backend-service -p "{\"spec\":{\"selector\":{\"app\":\"backend\",\"version\":\"${{ steps.next-color.outputs.BACKEND_NEXT }}\"}}}"
          kubectl patch service frontend-service -p "{\"spec\":{\"selector\":{\"app\":\"frontend\",\"version\":\"${{ steps.next-color.outputs.FRONTEND_NEXT }}\"}}}"

      - name: Wait for pods to be ready
        run: |
          kubectl rollout status deployment/backend-${{ steps.next-color.outputs.BACKEND_NEXT }} --timeout=120s
          kubectl rollout status deployment/frontend-${{ steps.next-color.outputs.FRONTEND_NEXT }} --timeout=120s

      - name: Health check
        id: health
        run: |
          INGRESS_IP=$(kubectl get ingress fractal-ingress -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          BACKEND_URL="https://$INGRESS_IP/api/health"
          FRONTEND_URL="http://$(kubectl get svc frontend-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}')"

          echo "Checking backend: $BACKEND_URL"
          curl -vk "$BACKEND_URL"

          echo "Checking frontend: $FRONTEND_URL"
          curl -vk "$FRONTEND_URL"

      - name: Rollback on Failure
        if: failure()
        run: |
          echo "Deployment failed â€” rolling back to previous version..."

          # Rollback backend
          PREV_BACKEND=$(kubectl get svc backend-service -o jsonpath='{.spec.selector.version}')
          ROLLBACK_COLOR=$( [ "$PREV_BACKEND" = "blue" ] && echo green || echo blue )
          kubectl patch service backend-service -p "{\"spec\":{\"selector\":{\"app\":\"backend\",\"version\":\"$ROLLBACK_COLOR\"}}}"

          # Rollback frontend
          PREV_FRONTEND=$(kubectl get svc frontend-service -o jsonpath='{.spec.selector.version}')
          ROLLBACK_COLOR=$( [ "$PREV_FRONTEND" = "blue" ] && echo green || echo blue )
          kubectl patch service frontend-service -p "{\"spec\":{\"selector\":{\"app\":\"frontend\",\"version\":\"$ROLLBACK_COLOR\"}}}"

          echo "Rollback complete."
